Особенности:

1) Переиспользуем байтбуфы
2) Вьюшки
3)

4) лимит - конечная точка, не можем выходить за его пределы(размер), [.. , start, ... , end, ...]
5) режим чтения, режим записи(только до end)
6) ресайз - увеличивает сайз, берет всегда новый из буфа(не доступен вьюшке)

7) использовать ByteBuf <-- ByteBufView
						<-- ByteBufImpl

	public ByteBufView view(start, end);


У буфа есть два режима - чтения и записи, потенциально и работа с ним мы можем разделить на две части:
процесс формирования байтбуфа и процесс его вычитывания и обработки

Когда мы получаем вью объекта - мы как бы говорим, что нам он нужен исключительно для чтения из него.
Это больше не конейнер, это фиксированные данные(как стринг). Следовательно желание каким либо образом изменить его(буф)
в этот момент выглядит странным.

В качестве примера:
Вычитываем из сети данные в буфер. Аппендим, ресайзим, пишем и т.д. после того как определенное количество данных вычитано,
передаем наш сформированный (или частично сформированный) байтбуф дальше - на обработку.

Сырые данные уже вычитаны, изменять на уровне обработки нельзя. Получаем вью - хедер, или боди или сериализированное
представление какой нибудь команды мессаджинга.

При всем этом, в изначальный буфер может что-то дописываться, он может ресайзится и т.д.



========================================================================================================================
Ближе к функциональному подходу -- каждый буф неизменяем, при попытке изменить всегда получаем новый с измененным
лимитом и офсетом


!! убрать флип

************************************************************************************************************************
